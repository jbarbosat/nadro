\chapter{Introducción}
\section{Geometría tropical}
\noindent Cuando alguien dice que está haciendo una tesis sobre criptografía tropical, la primera pregunta que recibe es: ¿por qué \textit{tropical}? A diferencia de lo que podríamos esperar, no se trata de construir triángulos con troncos de palmeras. El origen del término es bastante menos caricaturesco: fue acuñado por un grupo de computólogos franceses, incluyendo a Jean-Eric Pin \cite{pin} y Dominique Perrin \cite{perr}, en honor a su colega y amigo Imre Simon, quien fue un matemático y computólogo brasileño, pionero en el estudio de los llamados \textit{(min,+)-semirings}. El término \textit{tropical} tiene que ver con que Simon era de Brasil.

\bigskip En un blog llamado \textit{Computational Complexity}\footnote{La dirección del blog es \ttt{http://blog.computationalcomplexity.org/} y es escrito por Lance Fortnow and William Gasarch; profesores en Georgia Tech y en University of Maryland, respectivamente.}, se publicó tras el fallecimiento de Imre Simon en 2009, una entrada sobre sus intereses y algunos de sus resultados publicados. Dado que los componentes electrónicos de las computadoras trabajan con ceros y unos, es comprensible la importancia que tiene el estudio de álgebras booleanas en ciencias de la computación. Sin embargo, gracias al trabajo que Simon realizó a finales de la década de 1990, se hizo evidente la importancia de otras estructuras, tales como las álgebras tropicales, en el mismo campo. Muchos de los primeros documentos que se publicaron en relación con este tema hablan sobre aplicaciones diversas en ciencias de la computación \cite{pin}; sobre todo en teoría de autómatas finitos \cite{automat}.

\bigskip Actualmente mucha de la investigación sobre estructuras tropicales se lleva a cabo en geometría algebraica, por lo que se habla de \textit{geometría tropical}, más que de \textit{álgebra tropical}. El propósito de la geometría algebraica es estudiar propiedades geométricas de soluciones a ecuaciones algebraicas. Si tenemos soluciones únicas, no hay mucho que estudiar. Sin embargo, cuando tenemos muchas soluciones a una ecuación o ecuaciones, en ocasiones resulta útil conocer sus propiedades geométricas. Por ejemplo, si tenemos un polinomio con las operaciones de suma y producto a que estamos acostumbrados, podemos estudiar su \textit{tropicalización}; es decir, podemos cambiar las operaciones de suma por el mínimo y de multiplicación por la suma y ver qué tipo de objeto tenemos. A partir del estudio de la \textit{versión tropical} de variedades algebraicas podemos conocer información sobre ellas, por lo que muchos de los documentos que se publican actualmente tienen que ver con la adaptación de teoremas y definiciones de geometría algebraica al mundo tropical.

\bigskip También hay otras aplicaciones en muchas otras áreas de las matemáticas \cite{app}. Por ejemplo, algunas tienen que ver con la adaptación de conceptos de álgebra lineal, tales como la definición de independencia lineal \cite{lind}, espacios vectoriales \cite{mik} y transformaciones lineales \cite{puente}, rangos matriciales \cite{rank} y sistemas lineales sobre curvas tropicales \cite{tropicurv}. Se tienen también algoritmos para factorizar polinomios tropicales en una variable \cite{fund} y se han encontrado aplicaciones en teoría de juegos \cite{juegos}, sistemas de ecuaciones diferenciales parciales \cite{pde}, modelos estadísticos \cite{stat} e incluso física cuántica \cite{dequant}. Una de estas muchas aplicaciones es la elegida como centro de este trabajo: criptografía sobre álgebras tropicales.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Criptografía y complejidad computacional}

\noindent Como mencionamos antes, a pesar de que el uso de la criptografía es bastante común y generalizado en nuestros días, muchos de los primeros avances que se lograron en la materia surgieron a partir de necesidades militares. Muestra de ello es el artículo \cite{kerck} que en 1883 publicó el holandés Auguste Kerckhoffs en una revista de ciencias militares sobre este tema. En dicho documento, Kerckhoffs inicia con un breve recorrido histórico de la criptografía, tras lo cual expresa su preocupación por la falta de conocimientos criptográficos entre los miembros de rangos inferiores del ejército francés. Sobre todo en comparación con otros países, como Alemania, en donde no sólo se enseñaban métodos de encriptación a todos los soldados, sino que se enseñaba también la teoría detrás de ellos. Kerckhoffs cita a otros autores que critican la falta o exceso de complejidad de los algoritmos utilizados en la época. Esto lo lleva a proponer 6 requisitos, conocidos actualmente como \textit{Principios de Kerckhoffs}, que debe cumplir un criptosistema para ser seguro\footnote{Traducidos del artículo original \cite{kerck} en francés por la autora de este trabajo.}:
{\small 
\begin{enumerate}
\item El sistema debe ser material, si no matemáticamente, indescifrable.
\item No debe requerir mantenerse en secreto; debe poder caer en manos del enemigo sin que esto afecte su efectividad.
\item La clave debe poder ser comunicada y retenida sin ayuda de notas escritas y ser cambiada o modificada a criterio de los corresponsales.
\item Debe ser aplicable a la correspondencia telegráfica.
\item El sistema debe ser portátil y su uso no debe requerir la asistencia de varias personas.
\item Debe ser fácil de usar, sin necesidad de una larga serie de reglas que deban cumplirse.
\end{enumerate}}

Actualmente, principios como el 4 y el 5 se han descartado, gracias a la introducción de las computadoras. Sin embargo, sigue siendo fundamental que la seguridad no dependa del ocultamiento del algoritmo y que la encriptación sea rápida. El primer punto es, quizá, el más importante; los algoritmos que utilizamos actualmente tienen antecedentes matemáticos con distinto grado de dificultad, pero todos deben ser indescifrables \textit{en la práctica}. 

\bigskip Para entender mejor a qué nos referimos con esto, debemos remitirnos a la teoría de complejidad computacional, que clasifica los problemas de acuerdo con su dificultad en términos del tiempo que lleva resolverlos. A partir del siglo XVII se han inventado máquinas para facilitar esta tarea, tales como las calculadoras y computadoras. A pesar de que en 1936 Alan Turing probó que no todos los problemas pueden ser resueltos a través de algoritmos programados en máquinas, existen algunos que sí. Para ellos, se busca tener métodos cada vez más \textit{eficientes} que permitan llegar a una o varias soluciones o que indiquen si el problema no tiene solución. 

\bigskip El término \textit{eficiencia} puede resultar muy relativo. Por ello, para calcular el \textit{tiempo de ejecución} de un algoritmo, que es el tiempo que tarda en resolver cierto problema en el peor de los casos, se cuentan el número de operaciones elementales\footnote{Algunos ejemplos de operaciones elementales son: asignación de valores a una variable, condicionales, suma, resta, multiplicación y comparación entre variables.} que realiza. Dicha cantidad depende del tamaño de las entradas del algoritmo. Cuando tenemos entradas pequeñas, no hace mucha diferencia el utilizar algoritmos rápidos o lentos. Sin embargo, conforme aumenta el tamaño de las entradas, es cada vez más importante tener algoritmos bien diseñados. 

\bigskip Así, el tiempo de ejecución de un algoritmo puede verse como una función $f(n)$, donde $n$ es el tamaño de la entrada. Dado que en ocasiones resulta complicado calcular $f(n)$ de forma explícita, se busca una cota superior para ella. En general, se denota como $O(g(x))$ al conjunto de funciones que son acotadas superiormente por la función $\left|g(x)\right|$. Si $f(x)\in O(g(x))$, que también se puede denotar como $f(x)=O(g(x))$, esto significa que existen $x_0$ y $c>0$ tales que:
\[ \forall x\geq x_0, \ 0\leq \left|f(x)\right|\leq c\left|g(x)\right|.
\]

Volviendo al caso particular del cálculo del tiempo de ejecución de un algoritmo en donde $n$ es la longitud de su entrada, si $f(n)=O(g(n))$ y $g(n)$ es un polinomio, decimos que tenemos un \textit{algoritmo polinomial}. También podríamos tener algoritmos exponenciales o factoriales.

\bigskip En el siglo pasado en la década de los sesenta se popularizó el uso del término \textit{algoritmos polinomiales} para referirnos a aquellos métodos que resuelven un problema de manera \textit{rápida}. Gracias a este concepto fue posible clasificar los problemas de acuerdo con su dificultad: aquéllos que pueden resolverse rápidamente pertenecen a la clase $\mathcal{P}$ y aquéllos cuya solución puede verificarse de manera rápida, en tiempo polinomial, por una máquina de Turing no determinista\footnote{Una máquina de Turing determinista tiene sólo un posible estado al cual moverse después del actual. Una máquina no determinista tiene más de una opción, lo cual las hace más rápidas.} forman la clase $\mathcal{NP}$ (nondeterministic polynomial time) \cite{cravioto}. La clase $\mathcal{P}$ es subconjunto de la $\mathcal{NP}$, sin embargo, existen problemas en $\mathcal{NP}$ que no están en $\mathcal{P}$. Estos problemas son denominados $\mathcal{NP}-completos$ y actualmente no se conocen algoritmos polinomiales que nos permitan resolverlos. Tampoco se ha probado que estos algoritmos no existan. Por tanto, cuando uno se enfrenta a un problema de este tipo, a veces se opta por hacer una búsqueda exhaustiva o se construyen algoritmos que funcionan en muchos casos.

\bigskip Si queremos plantear un criptosistema seguro, un modo de hacerlo es basarnos en un problema que sabemos que es de clase $\mathcal{NP}-completo$\footnote{Por ejemplo, el llamado \textit{problema de satisfacibilidad booleana}, cuyo planteamiento puede consultarse en el Apéndice A de este documento.}. A lo largo de la historia se han elegido problemas cada vez más difíciles de resolver como centro de los criptosistemas propuestos, como se puede ver en el siguiente capítulo sobre el desarrollo histórico de la criptografía.

%\bigskip Como mencionamos con anterioridad, en el siguiente capítulo hacemos un resumen del desarrollo histórico de la criptografía. 